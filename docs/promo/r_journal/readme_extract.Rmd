{{ind2cat}} can help analysts translate from an indicator variables to categorical variables that can be used in reporting products.  By default, the categorical variable is created from the indicator variable name, resulting in a light weight syntax.

ind2cat's ind_recode function saves time by automatically creating meaningful categories based on a variable name as shown below:

```{r, eval = T}
library(tidyverse)
library(indicatorrecode)

data.frame(ind_graduated = c(T,T,F)) |>
  mutate(cat_graduated  = ind_recode(ind_graduated))
```
This can replace the less succinct approach:

```{r, eval = T}
data.frame(ind_graduated = c(T,T,F)) |>
  mutate(cat_graduated  = ifelse(ind_graduated, 
                                 "graduated", 
                                 "not graduated")) |>
  mutate(cat_graduated = fct_rev(cat_graduated))  
```


# Background:  *indicator variables a common and well understood way to store information.*

Indicator variables are often used in data analyses given the ease which with they are created, stored and interpreted.  They concisely encode information about the presence or not of a condition for observational units.

see.. https://emilyriederer.netlify.app/post/column-name-contracts/

In exploratory analyses indicator variables, analysts often make a choice between crafting an categorical variable whose values preserve the information that the indicator variable *name* holds, or using an indicator variable as-is; the later choice may be motivated by time savings.

# Problem:  Direct use of indicator variables in data products.

When indicator variables are not translated to a categorical analogue in creating data products like tables and visuals, information is often awkwardly displayed and is sometimes lost. 

```{r cars, fig.cap= c( "A. Bar labels + axis label preserves information but is awkward", "D. Facetting directly on an indicator variable with popular ggplot2 results in information loss")}
library(tidyverse)

tidytitanic::passengers %>% 
  ggplot() + 
  aes(x = survived) + 
  geom_bar()

tidytitanic::passengers %>% 
  count(survived) %>% 
  knitr::kable(caption = "B. Column header from variable name and 0-1 categories preserves information but is awkward")


tidytitanic::passengers %>% 
  janitor::tabyl(sex, survived) %>% 
  knitr::kable(caption = "C. Information loss with a two-way table for column variables")

tidytitanic::passengers %>% 
ggplot() + 
  aes(x = sex) + 
  geom_bar() + 
  facet_grid(~ survived)
```

# One-off solution:  *manual indicator recode, but is repetitive*



```{r}
tidytitanic::passengers %>% 
  tibble() %>% 
  mutate(cat_survived = ifelse(survived, "survived", "not survived"), 
         .before = 1)

tidytitanic::passengers %>% 
ggplot() + 
  aes(x = sex) + 
  geom_bar() + 
  facet_grid(~ ifelse(survived, "survived", "not survived"))
```

This solution above also does not address category display ordering; ordering in products will be alphabetical and not reflect the F/T order of the source variable.  An additional step to reflect the source variable, using a function like fct_rev, may be required for consistency in reporting.

```{r}
data.frame(ind_daytime = c(T, F, T, T)) %>% 
    mutate(cat_survived = ifelse(ind_daytime, "daytime", "not daytime")) %>% 
  mutate(cat_survived = fct_rev(cat_survived)) %>% 
  ggplot() + 
  aes(x = cat_survived) + 
  geom_bar()
```

# Introducing ind_recode  *ind_recode() function uses variable name as starting point for human-readable categories*


  
<!-- Usually I'll start with the sketch of a function right here, but then I eventually move it to an .R file. -->
  
```{r, echo = F}
code = readLines("R/ind_recode.R")
```
  
```{r, code = code, eval = T}

```

# to do

- change to Rlang for grabbing function name
- make "Y" "N" a lot stricter - right now we're assuming a ton!

# Basic examples:  *How to use ind_recode()* 

```{r}
library(tibble)
tibble(ind_grad = c(0,0,1,1,1 ,0 ,0)) %>%
  mutate(cat_grad  = ind_recode(ind_grad))

tibble(ind_grad = c(T,T,F)) %>%
  mutate(cat_grad  = ind_recode(ind_grad))

tibble(ind_grad = c("Y", "N")) %>%
  mutate(cat_grad  = ind_recode(ind_grad))

tibble(ind_grad = c("y", "n")) %>%
  mutate(cat_grad  = ind_recode(ind_grad))

tibble(ind_grad = c("yes", "no")) %>%
  mutate(cat_grad  = ind_recode(ind_grad))

```


# Customizability

We believe that ind_recode is useful in quickly translating to a human understandable outcome.  

However, addition functionality allows analysts to fully specify their preferences about the categories outputted.  


- var_prefix a character string that will be ignored when creating the categorical variable
- negator a character string used to create cat_false when cat_false is NULL, default is 'not'
- cat_true a character string string to be used place of  T/1/"Yes" for the categorical variable output, if NULL the category is automatically generated from the variable name
- cat_false a character string string to be used place of  F/0/"No" for the categorical variable output, if NULL the category is automatically generated from cat_true and the negator
- rev logical indicating if the order should be reversed from the F/T ordering of the indicator source variable, default is FALSE



## Customization examples


```{r}
tibble(dummy_grad = c(0,0,1,1,1 ,0 ,0)) %>%
  mutate(cat_grad  = ind_recode(dummy_grad, var_prefix = "dummy_"))

tibble(ind_grad = c(T,T,F)) %>%
  mutate(cat_grad  = ind_recode(ind_grad, negator = "didn't"))

tibble(ind_grad = c("Y", "N")) %>%
  mutate(cat_grad  = ind_recode(ind_grad, cat_false = "enrolled"))

tibble(ind_grad = c("y", "n")) %>%
  mutate(cat_grad  = ind_recode(ind_grad, 
                                cat_true = "graduated"))

tibble(ind_grad = c("y", "n")) %>%
  mutate(cat_grad  = ind_recode(ind_grad, 
                                cat_true = "graduated", 
                                cat_false = "enrolled"))

tibble(ind_grad = c("yes", "no")) %>%
  mutate(cat_grad  = ind_recode(ind_grad, rev = TRUE)) %>% 
  mutate(cat_grad_num = as.numeric(cat_grad))
```

## Use in data products like figures and tables



```{r}
tidytitanic::passengers %>% 
ggplot() + 
  aes(x = ind_recode(survived)) + 
  geom_bar()

# or
last_plot() +
  aes(x = ind_recode(survived, cat_false = "perished"))

  
# or
last_plot() +
  aes(x = ind_recode(survived, cat_false = "didn't", rev = T)) + 
  labs(x = NULL)

tidytitanic::passengers %>% 
ggplot() + 
  aes(x = sex) + 
  geom_bar() + 
  facet_grid(~ ind_recode(survived))

```

# Known Limitations:  *not for use with magrittr pipe (but base pipe works!)*

```{r}
tidytitanic::passengers %>% 
ggplot() + 
  aes(x = sex) + 
  geom_bar() + 
  facet_grid(~ survived %>% ind_recode())

tidytitanic::passengers %>% 
ggplot() + 
  aes(x = sex) + 
  geom_bar() + 
  facet_grid(~ survived |> ind_recode())
```


---

Afterward

# Other questions: *1) Is there already a solution and 2) fundamental problems with this approach?*

Please lemme know 'em! 

---

# worked example with tidytuesday data, Spam email

https://github.com/rfordatascience/tidytuesday/tree/master/data/2023/2023-08-15

```{r}
read.csv("https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-08-15/spam.csv") %>% 
  rename(spam = yesno) %>% 
  ggplot() + 
  aes(fill = ind_recode(bang>0), x = ind_recode(spam)) + 
  geom_bar(position = "dodge")

remove_layers <- function(plot, index = NULL){
  
  if(is.null(index)){
  plot$layers <- NULL
  }else{
  plot$layers[[index]] <- NULL
  }
  
 plot
  
}

last_plot_wiped <- function(index = NULL){
  
  plot <- last_plot()
  
  if(is.null(index)){
  plot$layers <- NULL
  }else{
  plot$layers[[index]] <- NULL
  }
  
 plot
  
}

last_plot_wiped() +
  geom_bar(position = "fill")


```
# learned along the way: `as_factor()` has different behavior than `as.factor()`

```{r}
c("Y", "N") %>% as_factor()
c("Y", "N") %>% as.factor()
```
